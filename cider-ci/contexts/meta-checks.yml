# Meta Checks

task_defaults:
  max_trials: 1
  traits:
    Linux: yes
    git: yes

tasks:

  git-log-debug:
    name: 'Git: Log (for debug)'
    scripts: {test: {body: "git log -n5"}}

  git-linear-history:
    name: 'Git: check linear history'
    scripts:
      test:
        body: |
          #!/usr/bin/env bash
          set -eux
          # no merges between GIT_LINEAR_HISTORY_CHECK_START_SHA and the current commit
          test -z $(git rev-list --merges ${GIT_LINEAR_HISTORY_CHECK_START_SHA}..HEAD)

  git-branch-current:
    name: "git tree contains latest commit from origin/master"
    scripts:
      main:
        body: |
          #!/usr/bin/env bash
          set -exu
          git fetch --all
          #
          # check if your tree still contains the current commit from master
          git rev-list --children HEAD | grep -q "$(git rev-parse origin/master)"

  git-submodules-current:
    name: "git submodules trees all contain latest commit from origin/master"
    git_options:
      submodules:
        include_match: ^.*$
    scripts:
      main:
        body: |
          #!/usr/bin/env bash
          set -exu

          # like `check-if-branch-current`, but for all the submodules, recursive.

          # make sure all submodules are checked out
          # WARNING: test is false-positive without this:
          git fetch --all
          git submodule update --init --recursive

          # <git ✨>
          # the lowercase variables come from git
          # lines explained in order:
          # - go to superproject (for this level of recursion)
          # - get current commit from remote master
          # - get current commit of submodule in current commit from remote master
          #     - abort if not found (bc it's a newly added submodule)
          # - go to the submodule
          # - check that the current submodule commit is still contained in tree
          git submodule foreach --recursive '\
            cd "${toplevel}" \
            && SUPER_HASH="$(git rev-parse origin/master)" \
            && SUB_HASH=$(git rev-parse ${SUPER_HASH}:${path}) \
              || { echo "new submodule - dont check!" && exit 0 ;} \
            && cd "${path}" \
            && git rev-list --children HEAD | grep -q "^${SUB_HASH}" \
              || { echo "FAIL! submodule ${path}" lost commit ${SUB_HASH}; exit 1 ;}'
          # </git ✨>

  # TODO: automate submodule integration and check here if linear merge possible
  git-submodules-merged:
    name: "git submodules are all merged to origin/master"
    git_options:
      submodules:
        include_match: ^.*$
    scripts:
      main:
        body:
          read_and_replace_with: cider-ci/bin/git-submodules-are-merged

